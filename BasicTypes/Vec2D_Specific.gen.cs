//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a _Vector_Specific.tt
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Runtime.CompilerServices;

namespace VectorCore
{

    public readonly partial struct Vec2D
    {
        public static double AngleDegrees(Vec2D from, Vec2D to) =>
            MathU.RadiansToDegrees(AngleRadians(from, to));
        public static double AngleRadians(Vec2D from, Vec2D to) =>
            Math.Acos(Math.Clamp(Dot(from.Normalized(), to.Normalized()), -1d, 1d));

        public static Vec2D Round(Vec2D v, int rounding = 8) =>
            new Vec2D( MathU.Round(v.x, rounding), MathU.Round(v.y, rounding) );
        public static Vec2D RadiansToDegrees(Vec2D v) => 
            new Vec2D( MathU.RadiansToDegrees(v.x), MathU.RadiansToDegrees(v.y) );
        public static Vec2D DegreesTo360PositiveDegrees(Vec2D v) =>
            new Vec2D( MathU.DegreesTo360PositiveDegrees(v.x), MathU.DegreesTo360PositiveDegrees(v.y) );

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vec2D Max(in Vec2D a, in Vec2D rhs) => 
            new Vec2D ( Math.Max(a.x, rhs.x), Math.Max(a.y, rhs.y) );
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vec2D Min(in Vec2D a, in Vec2D rhs) => 
            new Vec2D ( Math.Min(a.x, rhs.x), Math.Min(a.y, rhs.y) );
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double MagnitudeManhattan() => Math.Abs(x) + Math.Abs(y);//MathU.Abs(x) + MathU.Abs(y) + MathU.Abs(z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double DistanceSqr( Vec2D b) => (this - b).MagnitudeSqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double Distance(Vec2D b) => (this - b).Magnitude();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double DistanceManhattan(Vec2D b) => (this - b).MagnitudeManhattan();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly bool CloseByEach(Vec2D b, double epsilon = 1E-5d ) =>
            Math.Abs(x - b.x) < epsilon && Math.Abs(y - b.y) < epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly bool CloseBySqrDistance(Vec2D b, double sqrEpsilon = 1E-9d ) => DistanceSqr(this, b) <= sqrEpsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly bool CloseByDistance( Vec2D b, double epsilon = 1E-5d ) => Distance(this, b) <= epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool CloseByManhattan( Vec2D b, double epsilon = 1E-5d ) =>
            CloseByManhattan(this, b, epsilon);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static double DistanceSqr(Vec2D a, Vec2D b) => (a - b).MagnitudeSqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static double Distance(Vec2D a, Vec2D b) => (a - b).Magnitude();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static double DistanceManhattan(Vec2D a, Vec2D b) => (a - b).MagnitudeManhattan();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static bool CloseByEach(Vec2D a, Vec2D b, double epsilon = 1E-5d ) =>
            Math.Abs(a.x - b.x) < epsilon && Math.Abs(a.y - b.y) < epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static bool CloseBySqrDistance(Vec2D a, Vec2D b, double sqrEpsilon = 1E-9d ) => DistanceSqr(a, b) <= sqrEpsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static bool CloseByDistance(Vec2D a, Vec2D b, double epsilon = 1E-5d ) => Distance(a, b) <= epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CloseByManhattan(Vec2D a, Vec2D b, double epsilon = 1E-5d )
        {
            double d = Math.Abs(a.x - b.x);
            if (d > epsilon)
                return false;
            d += Math.Abs(a.y - b.y);
            if (d > epsilon)
                return false;
            return true;
        }


        public static Vec2D Project(in Vec2D vector, in Vec2D onNormal)
        {
            double onNormalSqrMagnitude = onNormal.MagnitudeSqr();
            if (onNormalSqrMagnitude < 1e-15d)
                return zero;
            double offset = Dot(vector, onNormal) / onNormalSqrMagnitude;
            return onNormal.Multiplied(offset);
        }


    }
}
