<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\_Include\_6_NoVector_Double_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_NoVector_Float_typeInitialization.ttinclude" #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace DoubleEngine
{
    public static partial class MathU
    {

    public const float EPSILON1_4 = 1e-4f; //0.0001f;
    public const float EPSILON1_7 = 1e-7f; //0.0000001f;
    public const float EPSILON2_6 = 2e-6f; //0.000002f;

<# 
for(var a = 0; a<availableTypes.Count; a++)
    {
    UnfoldTypeDescription(availableTypes[a]);
#>
        <#=aInline1CRLF8s#><#=publicStatic#> <#=b.type#> Map(<#=b.type#> x, <#=b.type#> in_min, <#=b.type#> in_max, <#=b.type#> out_min, <#=b.type#> out_max) =>
            (((x - in_min) * (out_max - out_min)) / (in_max - in_min)) + out_min;
        <#=aInline1CRLF8s#><#=publicStatic#> <#=b.type#> Sin(<#=b.type#> value) => <#=math["Sin"]#>(value);
        <#=aInline1CRLF8s#><#=publicStatic#> <#=b.type#> Cos(<#=b.type#> value) => <#=math["Cos"]#>(value);
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> Abs(<#=b.type#> value) => Math.Abs(value);//value < 0 ? -value : value;
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> Round(<#=b.type#> value, int rounding) => <#=math["Round"]#>(value, rounding);
        /// degrees * (Math.PI / 180d);
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> DegreesToRadians(<#=b.type#> degrees) => degrees * 0.0174532925199433<#=b.valueEnding#>;
        /// degrees * (Math.PI / 360d);
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> DegreesToHalfRadians(<#=b.type#> degrees) => degrees * 0.00872664625997165<#=b.valueEnding#>;

        /// radians * (180d / Math.PI);
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> RadiansToDegrees(<#=b.type#> radians) => radians * 57.2957795130823<#=b.valueEnding#>;
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> HalfRadiansToDegrees(<#=b.type#> halfRadians) => halfRadians * 114.591559026165<#=b.valueEnding#>;
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> RadiansToHalfRadians(<#=b.type#> Radians) => Radians * 0.5<#=b.valueEnding#>;
        <#=aInline#>
        <#=publicStatic#> <#=b.type#> HalfRadiansToRadians(<#=b.type#> halfRadians) => halfRadians * 2<#=b.valueEnding#>;

        <#=aInline#>
        <#=publicStatic#> <#=b.type#> DegreesTo360PositiveDegrees(<#=b.type#> deg)
        {
            deg = deg % 360; // Math.Round(deg, 8) % 360;
            return deg < 0 ? 360 + deg : deg;
        }

        <#=publicStatic#> <#=b.type#> Min(<#=b.type#> a, <#=b.type#> b) => a < b ? a : b;
        <#=publicStatic#> <#=b.type#> Max(<#=b.type#> a, <#=b.type#> b) => a > b ? a : b;


        <#=publicStatic#> bool IntervalsOverlap(<#=b.type#> interval1, <#=b.type#> interval2, out <#=b.type#> resultStart, out <#=b.type#>? resultEnd)
        {
            <#=b.type#> l = Max(0, Min(interval1, interval2));
            <#=b.type#> r = Min(1, Max(interval1, interval2));
            if (l > r)
            {
                resultStart = 0;
                resultEnd = null;
                return false;
            };
            resultStart = l;
            if (l == r)
            {
                resultEnd = null;
                return true;
            }
            resultEnd = r;
            return true;
        }
<# } #>
    }
}
