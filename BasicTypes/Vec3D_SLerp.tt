<#/*THIS IS A T4 FILE*/#>
<#@ template language="C#" #>
<#@ output extension=".gen.cs" #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_8_Vec3D_type.ttinclude" #>

using System;
using System.Runtime.CompilerServices;

namespace <#=globalNamespaceName#>
{

<#=publicReadonly#> partial struct <#=typeName#>
{
    public static <#=typeName#> Slerp(<#=typeName#> from, <#=typeName#> to, <#=b.type#> amount) =>
			SlerpUnclamped(from, to, Math.Clamp(amount, 0d, 1d));
	public static <#=typeName#> SlerpUnclamped(<#=typeName#> from, <#=typeName#> to, <#=b.type#> amount)
	{
    <#=typeName#> fromRotated = SphericallyRotatePoint(from, to, amount);
    <#=b.type#> backwardAmount = (1 - amount);
    <#=typeName#> toRotated = SphericallyRotatePoint(to, from, backwardAmount);
    return (toRotated * amount) + (fromRotated * backwardAmount);
    /*<#=b.type#> cosTheta = Dot(from.Normalized(), to.Normalized());
    <#=b.type#> theta = Math.Acos(cosTheta);
    <#=b.type#> sinTheta = Math.Sin(theta);
    //Debug.Log($"{cosTheta} {theta} {sinTheta}");

    if (sinTheta <= 0.0000001d)
        return from;

    <#=b.type#> w1 = Math.Sin((1 - amount) * theta) / sinTheta;
    <#=b.type#> w2 = Math.Sin(amount * theta) / sinTheta;
    return Multiply(from,w1) + Multiply(to,w2);*/
     /*<#=b.type#> dot = Dot(from.Normalized(), to.Normalized());
     //dot = Math.Clamp(dot, -1.0f, 1.0f);
     dot = MathU.Abs(dot);
     <#=b.type#> theta = Math.Acos(dot) * amount;
     <#=typeName#> RelativeVec = to - (from * dot);
     //RelativeVec.Normalize();
     return ((from*Math.Cos(theta)) + (to * Math.Sin(theta)));*/
	}

    public static Vec3D SphericallyRotatePoint(Vec3D point, Vec3D toDirection, double amount)
    {
        double angleTo = Vec3D.AngleRadians(point, toDirection);
        Vec3D cross = Vec3D.Cross(point, toDirection);
        QuaternionD q1 = QuaternionD.AngleAxis(MathU.RadiansToDegrees(angleTo) * amount, cross.Normalized());
        return q1.Rotate(point);
    }
}

}