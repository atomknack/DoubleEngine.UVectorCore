//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.CompilerServices;

namespace DoubleEngine
{
    public static partial class MathU
    {

    public const float EPSILON1_4 = 1e-4f; //0.0001f;
    public const float EPSILON1_7 = 1e-7f; //0.0000001f;
    public const float EPSILON2_6 = 2e-6f; //0.000002f;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Map(double x, double in_min, double in_max, double out_min, double out_max) =>
            (((x - in_min) * (out_max - out_min)) / (in_max - in_min)) + out_min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sin(double value) => Math.Sin(value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Cos(double value) => Math.Cos(value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Abs(double value) => Math.Abs(value);//value < 0 ? -value : value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Round(double value, int rounding) => Math.Round(value, rounding);
        /// degrees * (Math.PI / 180d);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DegreesToRadians(double degrees) => degrees * 0.0174532925199433d;
        /// degrees * (Math.PI / 360d);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DegreesToHalfRadians(double degrees) => degrees * 0.00872664625997165d;

        /// radians * (180d / Math.PI);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double RadiansToDegrees(double radians) => radians * 57.2957795130823d;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double HalfRadiansToDegrees(double halfRadians) => halfRadians * 114.591559026165d;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double RadiansToHalfRadians(double Radians) => Radians * 0.5d;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double HalfRadiansToRadians(double halfRadians) => halfRadians * 2d;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DegreesTo360PositiveDegrees(double deg)
        {
            deg = deg % 360; // Math.Round(deg, 8) % 360;
            return deg < 0 ? 360 + deg : deg;
        }

        public static double Min(double a, double b) => a < b ? a : b;
        public static double Max(double a, double b) => a > b ? a : b;


        public static bool IntervalsOverlap(double interval1, double interval2, out double resultStart, out double? resultEnd)
        {
            double l = Max(0, Min(interval1, interval2));
            double r = Min(1, Max(interval1, interval2));
            if (l > r)
            {
                resultStart = 0;
                resultEnd = null;
                return false;
            };
            resultStart = l;
            if (l == r)
            {
                resultEnd = null;
                return true;
            }
            resultEnd = r;
            return true;
        }
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Map(float x, float in_min, float in_max, float out_min, float out_max) =>
            (((x - in_min) * (out_max - out_min)) / (in_max - in_min)) + out_min;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sin(float value) => MathF.Sin(value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Cos(float value) => MathF.Cos(value);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Abs(float value) => Math.Abs(value);//value < 0 ? -value : value;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Round(float value, int rounding) => MathF.Round(value, rounding);
        /// degrees * (Math.PI / 180d);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DegreesToRadians(float degrees) => degrees * 0.0174532925199433f;
        /// degrees * (Math.PI / 360d);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DegreesToHalfRadians(float degrees) => degrees * 0.00872664625997165f;

        /// radians * (180d / Math.PI);
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float RadiansToDegrees(float radians) => radians * 57.2957795130823f;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float HalfRadiansToDegrees(float halfRadians) => halfRadians * 114.591559026165f;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float RadiansToHalfRadians(float Radians) => Radians * 0.5f;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float HalfRadiansToRadians(float halfRadians) => halfRadians * 2f;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DegreesTo360PositiveDegrees(float deg)
        {
            deg = deg % 360; // Math.Round(deg, 8) % 360;
            return deg < 0 ? 360 + deg : deg;
        }

        public static float Min(float a, float b) => a < b ? a : b;
        public static float Max(float a, float b) => a > b ? a : b;


        public static bool IntervalsOverlap(float interval1, float interval2, out float resultStart, out float? resultEnd)
        {
            float l = Max(0, Min(interval1, interval2));
            float r = Min(1, Max(interval1, interval2));
            if (l > r)
            {
                resultStart = 0;
                resultEnd = null;
                return false;
            };
            resultStart = l;
            if (l == r)
            {
                resultEnd = null;
                return true;
            }
            resultEnd = r;
            return true;
        }
    }
}
