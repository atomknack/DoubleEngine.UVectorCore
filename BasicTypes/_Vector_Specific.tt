<#@ template language="C#" hostspecific="True"#>
<#@ output extension=".gen.cs" #>
<#@ include file="$(ProjectDir)\_Include\_0_AssemplyImports.ttinclude" #>

<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

<#@ include file="$(ProjectDir)\_Include\_1_ManagerMultipleOutputHelper.ttinclude"#>
<#@ include file="$(ProjectDir)\_Include\_2_GlobalTTInclude.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_4_typeDeclaration.ttinclude" #>

<#@ include file="$(ProjectDir)\_Include\_6_Vec2D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec3D_typeInitialization.ttinclude" #>
<#@ include file="$(ProjectDir)\_Include\_6_Vec4D_typeInitialization.ttinclude" #>
<# FileInfo t4FileInfo = new FileInfo( this.Host.TemplateFile );#>
//// this file was generated as byproduct of generating *.gen.cs files from master template: <#=t4FileInfo.Name#>

<# var manager = Manager.Create(Host, GenerationEnvironment); #>
<# 

string extensionMethodThis = "";

string methodProject_Epsilon = "1e-15d"; // constant for method in _Vector_Specific.ttinclude
string epsilonDistance = "1E-5"+ b.valueEnding;
string epsilonSqrDistance = "1E-9"+ b.valueEnding;

for(var k = 0; k<availableTypes.Count; k++)
    {
    UnfoldTypeDescription(availableTypes[k]);

    epsilonDistance = "1E-5"+ b.valueEnding;
    epsilonSqrDistance = "1E-9"+ b.valueEnding;

    string filename = $"{typeName}_Specific.gen.cs";
    WriteLine($"//// Generating: {filename}");
    manager.StartNewFile(filename); #>
//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a <#=t4FileInfo.Name#>
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Runtime.CompilerServices;

namespace <#=globalNamespaceName#>
{

    <#=publicReadonly#> partial struct <#=typeName#>
    {
        <#=publicStatic#> <#=b.type#> AngleDegrees(<#=typeName#> from, <#=typeName#> to) =>
            MathU.RadiansToDegrees(AngleRadians(from, to));
        <#=publicStatic#> <#=b.type#> AngleRadians(<#=typeName#> from, <#=typeName#> to) =>
            <#=math["Acos"]#>(Math.Clamp(Dot(from.Normalized(), to.Normalized()), -1<#=b.valueEnding#>, 1<#=b.valueEnding#>));

        <#=publicStatic#> <#=typeName#> Round(<#=typeName#> v, int rounding = 8) =>
            new <#=typeName#>( <#=String.Join(", ",fieldNames.Select(x=> $"MathU.Round(v.{x}, rounding)"))#> );
        <#=publicStatic#> <#=typeName#> RadiansToDegrees(<#=typeName#> v) => 
            new <#=typeName#>( <#=String.Join(", ",fieldNames.Select(x=> $"MathU.RadiansToDegrees(v.{x})"))#> );
        <#=publicStatic#> <#=typeName#> DegreesTo360PositiveDegrees(<#=typeName#> v) =>
            new <#=typeName#>( <#=String.Join(", ",fieldNames.Select(x=> $"MathU.DegreesTo360PositiveDegrees(v.{x})"))#> );

        <#=aInline#>
        <#=publicStatic#> <#=typeName#> Max(<#=inMod#><#=typeName#> a, <#=inMod#><#=typeName#> rhs) => 
            new <#=typeName#> ( <#=String.Join(", ",fieldNames.Select(x=> $"Math.Max(a.{x}, rhs.{x})"))#> );
        <#=aInline#>
        <#=publicStatic#> <#=typeName#> Min(<#=inMod#><#=typeName#> a, <#=inMod#><#=typeName#> rhs) => 
            new <#=typeName#> ( <#=String.Join(", ",fieldNames.Select(x=> $"Math.Min(a.{x}, rhs.{x})"))#> );
        <#=aInline#> 
        <#=publicReadonly#> <#=b.type#> MagnitudeManhattan() => <#=String.Join(" + ",fieldNames.Select(x=> $"{math["Abs"]}({x})"))#>;//MathU.Abs(x) + MathU.Abs(y) + MathU.Abs(z);
<#@ include file="$(ProjectDir)\_Include\_Vector_Specific_Distance.ttinclude" #>
        <#=publicStatic#> <#=typeName#> Project(<#=inMod#><#=typeName#> vector, <#=inMod#><#=typeName#> onNormal)
        {
            <#=b.type#> onNormalSqrMagnitude = onNormal.MagnitudeSqr();
            if (onNormalSqrMagnitude < <#=methodProject_Epsilon#>)
                return zero;
            <#=b.type#> offset = Dot(vector, onNormal) / onNormalSqrMagnitude;
            return onNormal.Multiplied(offset);
        }


    }
}
<#  manager.EndBlock();
    } #>
<# manager.Process(true); #>