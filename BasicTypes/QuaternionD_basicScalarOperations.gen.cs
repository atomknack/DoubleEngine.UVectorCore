//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a _VectorLike_basicScalarOperations.tt
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;

namespace VectorCore
{

public readonly partial struct QuaternionD
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator +(in QuaternionD vector, double scalar) => new QuaternionD ( vector.x + scalar, vector.y + scalar, vector.z + scalar, vector.w + scalar );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator -(in QuaternionD vector) => new QuaternionD ( -vector.x, -vector.y, -vector.z, -vector.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator -(in QuaternionD vector, double scalar) => new QuaternionD ( vector.x - scalar, vector.y - scalar, vector.z - scalar, vector.w - scalar );

    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator *(in QuaternionD vector, double scalar) => new QuaternionD ( vector.x * scalar, vector.y * scalar, vector.z * scalar, vector.w * scalar );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD Multiply(in QuaternionD vector, double scalar) => new QuaternionD ( vector.x * scalar, vector.y * scalar, vector.z * scalar, vector.w * scalar );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly QuaternionD Multiplied(double scalar) => new QuaternionD ( x * scalar, y * scalar, z * scalar, w * scalar );
    
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator /(in QuaternionD vector, double scalarDivider) => new QuaternionD ( vector.x / scalarDivider, vector.y / scalarDivider, vector.z / scalarDivider, vector.w / scalarDivider );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD Divide(in QuaternionD vector, double scalarDivider) => new QuaternionD ( vector.x / scalarDivider, vector.y / scalarDivider, vector.z / scalarDivider, vector.w / scalarDivider );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly QuaternionD DividedBy(double divider) => new QuaternionD ( x / divider, y / divider, z / divider, w / divider );

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator %(in QuaternionD vector, double scalarDivider) => new QuaternionD ( vector.x % scalarDivider, vector.y % scalarDivider, vector.z % scalarDivider, vector.w % scalarDivider );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD RemainderOfDivision(in QuaternionD vector, double scalarDivider) => new QuaternionD ( vector.x % scalarDivider, vector.y % scalarDivider, vector.z % scalarDivider, vector.w % scalarDivider );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly QuaternionD RemainderOfDivision(double divider) => new QuaternionD ( x % divider, y % divider, z % divider, w % divider );

    /*
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator +(in QuaternionD lhs, in QuaternionD r) => new QuaternionD ( lhs.x + r.x, lhs.y + r.y, lhs.z + r.z, lhs.w + r.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD AddVect(in QuaternionD lhs, in QuaternionD r) => new QuaternionD ( lhs.x + r.x, lhs.y + r.y, lhs.z + r.z, lhs.w + r.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly QuaternionD AddedVect(in QuaternionD vector) => new QuaternionD ( x + vector.x, y + vector.y, z + vector.z, w + vector.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD operator -(in QuaternionD lhs, in QuaternionD r) => new QuaternionD ( lhs.x - r.x, lhs.y - r.y, lhs.z - r.z, lhs.w - r.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD MultiplyVect(in QuaternionD lhs, in QuaternionD r) => new QuaternionD ( lhs.x * r.x, lhs.y * r.y, lhs.z * r.z, lhs.w * r.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly QuaternionD MultipliedVect(in QuaternionD vector) => new QuaternionD ( x * vector.x, y * vector.y, z * vector.z, w * vector.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD DivideVect(in QuaternionD vector, in QuaternionD divider) => new QuaternionD ( vector.x / divider.x, vector.y / divider.y, vector.z / divider.z, vector.w / divider.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly QuaternionD DividedByVect(in QuaternionD divider) => new QuaternionD ( x / divider.x, y / divider.y, z / divider.z, w / divider.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static QuaternionD RemainderOfDivisionVect(in QuaternionD vector, in QuaternionD divider) => new QuaternionD ( vector.x % divider.x, vector.y % divider.y, vector.z % divider.z, vector.w % divider.w );
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public readonly QuaternionD RemainderOfDivisionVect(in QuaternionD divider) => new QuaternionD ( x % divider.x, y % divider.y, z % divider.z, w % divider.w );
    */
}

}
