//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool. Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;

namespace DoubleEngine
{

public readonly partial struct Vec3D
{
    public static Vec3D Slerp(Vec3D from, Vec3D to, double amount) =>
			SlerpUnclamped(from, to, Math.Clamp(amount, 0d, 1d));
	public static Vec3D SlerpUnclamped(Vec3D from, Vec3D to, double amount)
	{
    Vec3D fromRotated = SphericallyRotatePoint(from, to, amount);
    double backwardAmount = (1 - amount);
    Vec3D toRotated = SphericallyRotatePoint(to, from, backwardAmount);
    return (toRotated * amount) + (fromRotated * backwardAmount);
    /*double cosTheta = Dot(from.Normalized(), to.Normalized());
    double theta = Math.Acos(cosTheta);
    double sinTheta = Math.Sin(theta);
    //Debug.Log($"{cosTheta} {theta} {sinTheta}");

    if (sinTheta <= 0.0000001d)
        return from;

    double w1 = Math.Sin((1 - amount) * theta) / sinTheta;
    double w2 = Math.Sin(amount * theta) / sinTheta;
    return Multiply(from,w1) + Multiply(to,w2);*/
     /*double dot = Dot(from.Normalized(), to.Normalized());
     //dot = Math.Clamp(dot, -1.0f, 1.0f);
     dot = MathU.Abs(dot);
     double theta = Math.Acos(dot) * amount;
     Vec3D RelativeVec = to - (from * dot);
     //RelativeVec.Normalize();
     return ((from*Math.Cos(theta)) + (to * Math.Sin(theta)));*/
	}

    public static Vec3D SphericallyRotatePoint(Vec3D point, Vec3D toDirection, double amount)
    {
        double angleTo = Vec3D.AngleRadians(point, toDirection);
        Vec3D cross = Vec3D.Cross(point, toDirection);
        QuaternionD q1 = QuaternionD.AngleAxis(MathU.RadiansToDegrees(angleTo) * amount, cross.Normalized());
        return q1.Rotate(point);
    }
}

}