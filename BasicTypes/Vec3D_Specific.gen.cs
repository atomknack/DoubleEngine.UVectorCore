//----------------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a _Vector_Specific.tt
//     Changes will be lost if the code is regenerated.
// </auto-generated>
//----------------------------------------------------------------------------------------
using System;
using System.Runtime.CompilerServices;

namespace DoubleEngine
{

    public readonly partial struct Vec3D
    {
        public static double AngleDegrees(Vec3D from, Vec3D to) =>
            MathU.RadiansToDegrees(AngleRadians(from, to));
        public static double AngleRadians(Vec3D from, Vec3D to) =>
            Math.Acos(Math.Clamp(Dot(from.Normalized(), to.Normalized()), -1d, 1d));

        public static Vec3D Round(Vec3D v, int rounding = 8) =>
            new Vec3D( MathU.Round(v.x, rounding), MathU.Round(v.y, rounding), MathU.Round(v.z, rounding) );
        public static Vec3D RadiansToDegrees(Vec3D v) => 
            new Vec3D( MathU.RadiansToDegrees(v.x), MathU.RadiansToDegrees(v.y), MathU.RadiansToDegrees(v.z) );
        public static Vec3D DegreesTo360PositiveDegrees(Vec3D v) =>
            new Vec3D( MathU.DegreesTo360PositiveDegrees(v.x), MathU.DegreesTo360PositiveDegrees(v.y), MathU.DegreesTo360PositiveDegrees(v.z) );

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vec3D Max(in Vec3D a, in Vec3D rhs) => 
            new Vec3D ( Math.Max(a.x, rhs.x), Math.Max(a.y, rhs.y), Math.Max(a.z, rhs.z) );
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Vec3D Min(in Vec3D a, in Vec3D rhs) => 
            new Vec3D ( Math.Min(a.x, rhs.x), Math.Min(a.y, rhs.y), Math.Min(a.z, rhs.z) );
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double MagnitudeManhattan() => Math.Abs(x) + Math.Abs(y) + Math.Abs(z);//MathU.Abs(x) + MathU.Abs(y) + MathU.Abs(z);
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double DistanceSqr( Vec3D b) => (this - b).MagnitudeSqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double Distance(Vec3D b) => (this - b).Magnitude();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly double DistanceManhattan(Vec3D b) => (this - b).MagnitudeManhattan();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly bool CloseByEach(Vec3D b, double epsilon = 1E-5d ) =>
            Math.Abs(x - b.x) < epsilon && Math.Abs(y - b.y) < epsilon && Math.Abs(z - b.z) < epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly bool CloseBySqrDistance(Vec3D b, double sqrEpsilon = 1E-9d ) => DistanceSqr(this, b) <= sqrEpsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public readonly bool CloseByDistance( Vec3D b, double epsilon = 1E-5d ) => Distance(this, b) <= epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public readonly bool CloseByManhattan( Vec3D b, double epsilon = 1E-5d ) =>
            CloseByManhattan(this, b, epsilon);

        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static double DistanceSqr(Vec3D a, Vec3D b) => (a - b).MagnitudeSqr();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static double Distance(Vec3D a, Vec3D b) => (a - b).Magnitude();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static double DistanceManhattan(Vec3D a, Vec3D b) => (a - b).MagnitudeManhattan();
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static bool CloseByEach(Vec3D a, Vec3D b, double epsilon = 1E-5d ) =>
            Math.Abs(a.x - b.x) < epsilon && Math.Abs(a.y - b.y) < epsilon && Math.Abs(a.z - b.z) < epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static bool CloseBySqrDistance(Vec3D a, Vec3D b, double sqrEpsilon = 1E-9d ) => DistanceSqr(a, b) <= sqrEpsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)] 
        public static bool CloseByDistance(Vec3D a, Vec3D b, double epsilon = 1E-5d ) => Distance(a, b) <= epsilon;
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool CloseByManhattan(Vec3D a, Vec3D b, double epsilon = 1E-5d )
        {
            double d = Math.Abs(a.x - b.x);
            if (d > epsilon)
                return false;
            d += Math.Abs(a.y - b.y);
            if (d > epsilon)
                return false;
            d += Math.Abs(a.z - b.z);
            if (d > epsilon)
                return false;
            return true;
        }


        public static Vec3D Project(in Vec3D vector, in Vec3D onNormal)
        {
            double onNormalSqrMagnitude = onNormal.MagnitudeSqr();
            if (onNormalSqrMagnitude < 1e-15d)
                return zero;
            double offset = Dot(vector, onNormal) / onNormalSqrMagnitude;
            return onNormal.Multiplied(offset);
        }


    }
}
